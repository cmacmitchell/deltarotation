from AlgorithmImports import *
from datetime import timedelta, date

class DeltaIV_LogFast(QCAlgorithm):
    def Initialize(self):
        # -------- Backtest params --------
        self.SetStartDate(2020, 1, 1)
        self.SetEndDate(2021, 1, 1)
        self.SetCash(100000)

        # Universe
        self.tickers = [
            "AAPL","MSFT","NFLX","GOOGL","AMZN","TSLA","AVGO","META",
            "WMT","NVDA","JPM","ORCL","V","LLY","MA","DIS",
            "XOM","PLTR","COST","JNJ","HD","PG","ABBV","BAC","CVX","KO","GE"
        ]

        # Equities MINUTE for spot (RAW); options HOURLY to keep it light
        self.equity = {}
        self.canonical = {}
        for t in self.tickers:
            eq = self.AddEquity(t, Resolution.Minute, dataNormalizationMode=DataNormalizationMode.Raw)
            self.equity[t] = eq.Symbol
            self.canonical[t] = self.AddOption(t, Resolution.Hour).Symbol

        # ------ Option selection params ------
        self.DTE_MIN, self.DTE_MAX, self.DTE_TARGET = 20, 45, 30
        self.OTM_FACTOR = 1.015
        self.TOP_WEIGHTS = [0.20, 0.20, 0.20, 0.20, 0.20]

        # ------ Rebalance cadence ------
        self.period_days = 30
        self.lastWindowDate: date | None = None
        self.windowOpen = False
        self.scores, self.reasons = {}, {}

        # Buy & hold benchmark
        self.bh_initialized = False
        self.bh_shares = {t: 0.0 for t in self.tickers}
        self.bh_start_value = float(self.Portfolio.Cash)
        self.bh_value = 0.0

        # Logging
        self.pending = []
        self.completed = []
        self.csv_header = "time,ticker,delta,iv,score,spot,dte,expiry,strike,is_winner,ret_90d\n"

        # ====== Always-on Hedge: 5% SQQQ + 3% VIXY ======
        self.hedge_symbols = {
            "SQQQ": self.AddEquity("SQQQ", Resolution.Minute, dataNormalizationMode=DataNormalizationMode.Raw).Symbol,
            "VIXY": self.AddEquity("VIXY", Resolution.Minute, dataNormalizationMode=DataNormalizationMode.Raw).Symbol
        }
        self.hedge_allocations = {"SQQQ": 0.05, "VIXY": 0.03}

        # Schedules
        ref = self.equity["AAPL"]
        self.SetWarmUp(timedelta(days=1))
        self.Schedule.On(self.DateRules.EveryDay(ref), self.TimeRules.At(9, 35), self.OpenIfDue)
        self.Schedule.On(self.DateRules.EveryDay(ref), self.TimeRules.At(10, 45), self.DecideIfOpen)
        self.Schedule.On(self.DateRules.EveryDay(ref), self.TimeRules.At(15, 55), self.ProcessPending)

    # Helpers
    def _due(self) -> bool:
        if self.lastWindowDate is None:
            return True
        return (self.Time.date() - self.lastWindowDate).days >= self.period_days

    # Open scoring window
    def OpenIfDue(self):
        if self.IsWarmingUp or not self._due():
            return
        self.windowOpen = True
        self.scores.clear()
        self.reasons.clear()

    # Decide positions
    def DecideIfOpen(self):
        if not self.windowOpen:
            return

        # Score tickers
        for t in self.tickers:
            if t in self.scores or t in self.reasons:
                continue
            pack = self._score_via_df(t)
            if pack is None:
                continue
            (score, delta, iv, spot, dte, expiry, strike) = pack
            self.scores[t] = score
            self.pending.append({
                "open_date": self.Time.date(),
                "due_date":  self.Time.date() + timedelta(days=90),
                "ticker":    t,
                "spot":      spot,
                "delta":     delta,
                "iv":        iv,
                "score":     score,
                "dte":       dte,
                "expiry":    expiry.date(),
                "strike":    strike,
                "is_winner": 0
            })

        if not self.scores:
            self.windowOpen = False
            self.lastWindowDate = self.Time.date()
            return

        ordered = sorted(self.scores.items(), key=lambda kv: kv[1], reverse=True)
        picks = [t for t, _ in ordered[:5]]

        # Allocate only 92% of portfolio to equities (rest is hedge)
        weights = self.TOP_WEIGHTS[:len(picks)]
        s = sum(weights)
        if s > 0:
            weights = [w / s * 0.92 for w in weights]  # scale down to 92%

        self.Liquidate()

        # Always-on hedge
        for hedge, alloc in self.hedge_allocations.items():
            self.SetHoldings(self.hedge_symbols[hedge], alloc)

        # Rotational equities
        for t, w in zip(picks, weights):
            self.SetHoldings(self.equity[t], w)

        # Mark winners
        today = self.Time.date()
        winners = set(picks)
        for row in self.pending:
            if row["open_date"] == today and row["ticker"] in winners:
                row["is_winner"] = 1

        self.windowOpen = False
        self.lastWindowDate = self.Time.date()

        # Initialize Buy & Hold benchmark
        if not self.bh_initialized:
            per = self.bh_start_value / float(len(self.tickers))
            for t in self.tickers:
                px = self.Securities[self.equity[t]].Price
                if px > 0:
                    self.bh_shares[t] = per / px
            self.bh_initialized = True

    # Scoring logic
    def _score_via_df(self, t: str):
        try:
            df = self.OptionChain(self.canonical[t], flatten=True).data_frame
            if df is None or df.empty:
                self.reasons[t] = "empty df"
                return None

            right = df['right'].astype(str).str.upper().str[0]
            df = df[(right == 'C') & (df['expiry'] > self.Time)]
            if df.empty:
                self.reasons[t] = "no calls"
                return None

            dte = (df['expiry'] - self.Time).dt.days
            df = df[dte.between(self.DTE_MIN, self.DTE_MAX)]
            if df.empty:
                self.reasons[t] = f"no {self.DTE_MIN}-{self.DTE_MAX}d"
                return None

            df = df.assign(dte=(df['expiry'] - self.Time).dt.days)
            target_expiry = df.iloc[(df['dte'] - self.DTE_TARGET).abs().argsort()].iloc[0]['expiry']
            sub = df[df['expiry'] == target_expiry]
            if sub.empty:
                self.reasons[t] = "no rows @ target expiry"
                return None

            spot = float(sub['underlyinglastprice'].iloc[0])
            if not spot or spot <= 0:
                self.reasons[t] = "bad spot"
                return None

            target = spot * self.OTM_FACTOR
            sub = sub.assign(abs_strike_delta=(sub['strike'] - target).abs())
            row = sub.loc[sub['abs_strike_delta'].idxmin()]

            iv = float(row.get('impliedvolatility', float('nan')))
            delta = float(row.get('delta', float('nan')))
            if not (iv and delta) or iv == 0 or (delta != delta) or (iv != iv):
                self.reasons[t] = "missing greeks"
                return None

            score = abs(delta)
            return score, float(delta), float(iv), float(spot), int(row['dte']), row['expiry'], float(row['strike'])
        except Exception as e:
            self.reasons[t] = f"df err:{e}"
            return None

    # Process 90d returns
    def ProcessPending(self):
        if not self.pending:
            if self.bh_initialized:
                self.bh_value = sum(self.bh_shares[t] * self.Securities[self.equity[t]].Price for t in self.tickers)
            return

        today = self.Time.date()
        flush_rows = []
        still_waiting = []

        for row in self.pending:
            if row["due_date"] > today:
                still_waiting.append(row)
                continue

            sym = self.equity[row["ticker"]]
            cur_px = self.Securities[sym].Price
            if cur_px and cur_px > 0 and row["spot"] > 0:
                ret = (cur_px / row["spot"]) - 1.0
            else:
                ret = float('nan')

            csv = (
                "{time},{tic},{d:.6f},{iv:.6f},{sc:.6f},{sp:.6f},{dte},{exp},{k:.4f},{win},{ret:.6f}\n"
                .format(
                    time=row["open_date"], tic=row["ticker"], d=row["delta"], iv=row["iv"], sc=row["score"],
                    sp=row["spot"], dte=row["dte"], exp=row["expiry"], k=row["strike"], win=row["is_winner"], ret=ret
                )
            )
            flush_rows.append(csv)

        self.pending = still_waiting

        if flush_rows:
            self.completed.extend(flush_rows)
            try:
                content = self.csv_header + "".join(self.completed)
                self.ObjectStore.Save("delta_iv_samples.csv", content)
            except Exception as e:
                self.Debug(f"ObjectStore save failed: {e}")

        if self.bh_initialized:
            self.bh_value = sum(self.bh_shares[t] * self.Securities[self.equity[t]].Price for t in self.tickers)

    # End of algo
    def OnEndOfAlgorithm(self):
        try:
            content = self.csv_header + "".join(self.completed)
            self.ObjectStore.Save("delta_iv_samples.csv", content)
            self.Debug("Saved delta_iv_samples.csv to ObjectStore")
        except Exception as e:
            self.Debug(f"Final ObjectStore save failed: {e}")

        if self.bh_initialized and self.bh_start_value > 0:
            bh_ret = (self.bh_value / self.bh_start_value) - 1.0
            strat_ret = (self.Portfolio.TotalPortfolioValue / self.bh_start_value) - 1.0
            self.Debug(f"Buy&Hold (equal-weight) return: {bh_ret:.2%}")
            self.Debug(f"Strategy return: {strat_ret:.2%}")
