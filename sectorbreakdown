from AlgorithmImports import *
from datetime import timedelta, date

class DeltaIV_BySector(QCAlgorithm):
    def Initialize(self):
        # -------- Backtest params --------
        self.SetStartDate(2023, 1, 1)
        self.SetEndDate(2024, 1, 1)
        self.SetCash(100000)

        # ===== Regime driver: SPY SMA(25/50) =====
        self.spy  = self.AddEquity("SPY", Resolution.Minute, dataNormalizationMode=DataNormalizationMode.Raw).Symbol
        self.sma25 = self.SMA(self.spy, 25, Resolution.Daily)
        self.sma50 = self.SMA(self.spy, 50, Resolution.Daily)

        # ===== Sector membership (symbols mapped from your sheet) =====
        self.sector_universe = {
            "IT":   ["AAPL","MSFT","NVDA","ADBE","AVGO","CRM","ORCL","CSCO","INTC","ACN","IBM","TXN"],
            "HC":   ["UNH","JNJ","LLY","PFE","TMO","ABT","ABBV"],
            "FIN":  ["V","MA","JPM","GS","C","PYPL","BLK","BAC"],
            "CD":   ["AMZN","TSLA","MCD","NKE","HD","TJX","LOW","AZO"],
            "IND":  ["UPS","HON","ADP","CAT","BA","LMT","MMM","GE","RTX"],
            "COMM": ["GOOG","META","NFLX","DIS","CMCSA","VZ","T","WBD"],
            "CS":   ["PG","COST","KO","PEP","WMT","TGT","GIS","MO","STZ"],
            "ENE":  ["XOM","CVX","COP","PXD","OXY","EOG","SLB","HAL","PSX"],
            "UTIL": ["NEE","CEG","SO","DUK","VST","D","AEP","EXC","PEG"],
            "MAT":  ["LIN","SHW","DOW","FCX","NEM","NUE","IP","ALB"],
            "RE":   ["PLD","EQIX","AMT","SPG","O","PSA","WELL","DLR"]
        }

        # ===== Per-regime sector quotas (from your table) =====
        self.quota_by_regime = {
            "ON":  {"IT":3, "HC":0, "FIN":1, "CD":3, "IND":2, "COMM":3, "CS":0, "ENE":0, "UTIL":0, "MAT":1, "RE":1},
            "MID": {"IT":2, "HC":1, "FIN":2, "CD":2, "IND":3, "COMM":1, "CS":0, "ENE":1, "UTIL":1, "MAT":2, "RE":1},
            "OFF": {"IT":2, "HC":3, "FIN":1, "CD":1, "IND":1, "COMM":1, "CS":3, "ENE":2, "UTIL":4, "MAT":2, "RE":2},
        }

        # ===== Data subscriptions (equities + options for scoring) =====
        self.equity = {}
        self.canonical = {}
        for _, names in self.sector_universe.items():
            for t in names:
                if t in self.equity:   # avoid dupes
                    continue
                eq = self.AddEquity(t, Resolution.Minute,
                                    dataNormalizationMode=DataNormalizationMode.Raw)
                self.equity[t] = eq.Symbol
                self.canonical[t] = self.AddOption(t, Resolution.Hour).Symbol

        # ------ Delta engine params (updated for 60-day horizon) ------
        self.DTE_MIN, self.DTE_MAX, self.DTE_TARGET = 10, 25, 14   # days
        self.OTM_FACTOR = 1.015                                   # ~ +2.25% OTM strike target

        # ------ State & logging ------
        self.current_regime = None
        self.current_names  = []
        self.scores, self.reasons = {}, {}

        # 90d realized returns logging
        self.pending = []
        self.completed = []
        self.csv_header = "time,ticker,delta,iv,score,spot,dte,expiry,strike,is_winner,ret_90d\n"

        # Buy & hold benchmark
        universe_all = sorted({t for names in self.sector_universe.values() for t in names})
        self.bh_initialized = False
        self.bh_shares = {t: 0.0 for t in universe_all}
        self.bh_start_value = float(self.Portfolio.Cash)
        self.bh_value = 0.0

        # Warm up enough for SMAs and options
        self.SetWarmUp(90, Resolution.Daily)

        # ------ Rebalance cadence ------
        self.period_days = 14
        self.lastWindowDate = None
        self.windowOpen = False

        # Monthly/periodic window (we keep the daily check but only act every 60 days)
        ref = self.spy
        self.Schedule.On(self.DateRules.EveryDay(ref), self.TimeRules.At(9, 35), self.OpenIfDue)
        self.Schedule.On(self.DateRules.EveryDay(ref), self.TimeRules.At(10, 45), self.DecideIfOpen)

        # Intramonth regime flips → immediate rebalance
        self.Schedule.On(self.DateRules.EveryDay(ref), self.TimeRules.At(10, 5), self.RebalanceIfRegimeChanged)

        # End-of-day logging
        self.Schedule.On(self.DateRules.EveryDay(ref), self.TimeRules.At(15, 55), self.ProcessPending)

    # ========= Regime logic =========
    def _get_regime(self):
        if not (self.sma25.IsReady and self.sma50.IsReady):
            return "ON"  # default bullish until indicators ready
        px = self.Securities[self.spy].Price
        if px is None or px <= 0:
            return self.current_regime or "ON"
        if px >= self.sma25.Current.Value:
            return "ON"
        if px >= self.sma50.Current.Value:
            return "MID"
        return "OFF"

    # ========= Cadence helpers =========
    def _due(self) -> bool:
        if self.lastWindowDate is None:
            return True
        return (self.Time.date() - self.lastWindowDate).days >= self.period_days

    def OpenIfDue(self):
        if self.IsWarmingUp or not self._due():
            return
        self.windowOpen = True
        self.scores.clear()
        self.reasons.clear()

    def RebalanceIfRegimeChanged(self):
        if self.IsWarmingUp: return
        reg = self._get_regime()
        if reg != self.current_regime:
            self.Debug(f"Regime change: {self.current_regime} -> {reg}")
            self._score_all_and_apply(reg, reason="regime_change")

    # ========= Periodic decision (every 60 days) =========
    def DecideIfOpen(self):
        if not self.windowOpen:
            return
        reg = self._get_regime()
        self._score_all_and_apply(reg, reason="periodic_60d")
        self.windowOpen = False
        self.lastWindowDate = self.Time.date()

        # Initialize B&H on first decision day
        if not self.bh_initialized:
            universe = sorted({t for names in self.sector_universe.values() for t in names})
            per = self.bh_start_value / float(len(universe))
            for t in universe:
                sym = self.equity.get(t)
                if sym is None: continue
                px = self.Securities[sym].Price
                if px and px > 0:
                    self.bh_shares[t] = per / px
            self.bh_initialized = True

    # ========= Core: rank deltas inside each sector, then apply quotas =========
    def _score_all_and_apply(self, regime: str, reason: str):
        # 1) Build per-sector scored lists [(ticker, score), ...], score = |delta|
        scored_by_sector = {sec: [] for sec in self.sector_universe.keys()}
        logs_today = []

        for sec, names in self.sector_universe.items():
            for t in names:
                pack = self._score_via_df(t)
                if pack is None:
                    continue
                (score, delta, iv, spot, dte, expiry, strike) = pack
                scored_by_sector[sec].append((t, score))

                logs_today.append({
                    "open_date": self.Time.date(),
                    "due_date":  self.Time.date() + timedelta(days=90),
                    "ticker":    t,
                    "spot":      spot,
                    "delta":     delta,
                    "iv":        iv,
                    "score":     score,
                    "dte":       dte,
                    "expiry":    expiry.date(),
                    "strike":    strike,
                    "is_winner": 0
                })

        # Append logs for all scored tickers (winners flagged later)
        if logs_today:
            self.pending.extend(logs_today)

        # 2) Apply quotas for this regime: take top X per sector by score desc
        quotas = self.quota_by_regime.get(regime, {})
        picks = []
        for sec, need in quotas.items():
            if need <= 0: 
                continue
            candidates = scored_by_sector.get(sec, [])
            if not candidates:
                continue
            candidates.sort(key=lambda x: x[1], reverse=True)  # score desc
            picks.extend([t for (t, _) in candidates[:need]])

        if not picks:
            self.Debug(f"No eligible picks for regime={regime} (insufficient options/quotes).")
            return

        # 3) Liquidate any equities not selected; then equal-weight the chosen names (100% invested, no hedge)
        keep = set(picks)
        for sec, names in self.sector_universe.items():
            for t in names:
                sym = self.equity[t]
                if t not in keep and self.Portfolio[sym].Invested:
                    self.Liquidate(sym)

        w = 1.0 / float(len(picks))
        for t in picks:
            self.SetHoldings(self.equity[t], w)

        # Mark "winners" = those selected today
        today = self.Time.date()
        for row in self.pending:
            if row["open_date"] == today and row["ticker"] in keep:
                row["is_winner"] = 1

        self.current_regime = regime
        self.current_names = picks
        self.Debug(f"{reason} applied. Regime={regime}, names={len(picks)}, weight each={w:.2%}")

    # ========= Delta scoring via flattened chain DF (60DTE, +2.25% OTM) =========
    def _score_via_df(self, t: str):
        """Return (score=|delta|, delta, iv, spot, dte, expiry, strike) or None."""
        try:
            ch = self.OptionChain(self.canonical[t], flatten=True)
            df = ch.data_frame if ch is not None else None
            if df is None or df.empty:
                self.reasons[t] = "empty df"
                return None

            # Calls only, future expiries
            right = df['right'].astype(str).str.upper().str[0]
            df = df[(right == 'C') & (df['expiry'] > self.Time)]
            if df.empty:
                self.reasons[t] = "no calls"
                return None

            # DTE filter 45–75, target ~60
            dte = (df['expiry'] - self.Time).dt.days
            df = df[dte.between(self.DTE_MIN, self.DTE_MAX)]
            if df.empty:
                self.reasons[t] = f"no {self.DTE_MIN}-{self.DTE_MAX}d"
                return None

            df = df.assign(dte=(df['expiry'] - self.Time).dt.days)
            target_expiry = df.iloc[(df['dte'] - self.DTE_TARGET).abs().argsort()].iloc[0]['expiry']
            sub = df[df['expiry'] == target_expiry]
            if sub.empty:
                self.reasons[t] = "no rows @ target expiry"
                return None

            spot = float(sub['underlyinglastprice'].iloc[0])
            if not spot or spot <= 0:
                self.reasons[t] = "bad spot"
                return None

            # Aim ~ +2.25% OTM strike
            target = spot * self.OTM_FACTOR
            sub = sub.assign(abs_strike_delta=(sub['strike'] - target).abs())
            row = sub.loc[sub['abs_strike_delta'].idxmin()]

            iv = float(row.get('impliedvolatility', float('nan')))
            delta = float(row.get('delta', float('nan')))
            if not (iv and delta) or iv == 0 or (delta != delta) or (iv != iv):
                self.reasons[t] = "missing greeks"
                return None

            score = abs(delta)  # your probability proxy at 60DTE / +2.25% OTM
            return score, float(delta), float(iv), float(spot), int(row['dte']), row['expiry'], float(row['strike'])
        except Exception as e:
            self.reasons[t] = f"df err:{e}"
            return None

    # ========= 90-day realized returns logging =========
    def ProcessPending(self):
        if not self.pending:
            if self.bh_initialized:
                # Update B&H mark
                universe = {t for names in self.sector_universe.values() for t in names}
                self.bh_value = sum(self.Securities[self.equity[t]].Price * self.bh_shares[t]
                                    for t in universe if t in self.equity)
            return

        today = self.Time.date()
        flush_rows, still_waiting = [], []

        for row in self.pending:
            if row["due_date"] > today:
                still_waiting.append(row)
                continue

            t = row["ticker"]
            sym = self.equity.get(t)
            cur_px = self.Securities[sym].Price if sym else None
            if cur_px and cur_px > 0 and row["spot"] > 0:
                ret = (cur_px / row["spot"]) - 1.0
            else:
                ret = float('nan')

            csv = (
                "{time},{tic},{d:.6f},{iv:.6f},{sc:.6f},{sp:.6f},{dte},{exp},{k:.4f},{win},{ret:.6f}\n"
                .format(
                    time=row["open_date"], tic=row["ticker"], d=row["delta"], iv=row["iv"], sc=row["score"],
                    sp=row["spot"], dte=row["dte"], exp=row["expiry"], k=0.0,
                    win=row["is_winner"], ret=ret
                )
            )
            flush_rows.append(csv)

        self.pending = still_waiting

        if flush_rows:
            self.completed.extend(flush_rows)
            try:
                content = self.csv_header + "".join(self.completed)
                self.ObjectStore.Save("delta_iv_samples.csv", content)
            except Exception as e:
                self.Debug(f"ObjectStore save failed: {e}")

        # Update B&H mark
        if self.bh_initialized:
            universe = {t for names in self.sector_universe.values() for t in names}
            self.bh_value = sum(self.Securities[self.equity[t]].Price * self.bh_shares[t]
                                for t in universe if t in self.equity)

    def OnEndOfAlgorithm(self):
        try:
            content = self.csv_header + "".join(self.completed)
            self.ObjectStore.Save("delta_iv_samples.csv", content)
            self.Debug("Saved delta_iv_samples.csv to ObjectStore")
        except Exception as e:
            self.Debug(f"Final ObjectStore save failed: {e}")

        if self.bh_initialized and self.bh_start_value > 0:
            bh_ret = (self.bh_value / self.bh_start_value) - 1.0
            strat_ret = (self.Portfolio.TotalPortfolioValue / self.bh_start_value) - 1.0
            self.Debug(f"Buy&Hold (equal-weight) return: {bh_ret:.2%}")
            self.Debug(f"Strategy return: {strat_ret:.2%}")
